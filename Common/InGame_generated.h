// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INGAME_H_
#define FLATBUFFERS_GENERATED_INGAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

struct PlayerInfo;
struct PlayerInfoBuilder;

struct PositionInfo;
struct PositionInfoBuilder;

struct SkillInfo;
struct SkillInfoBuilder;

struct SC_ENTER_GAME;
struct SC_ENTER_GAMEBuilder;

struct SC_LEAVE_GAME;
struct SC_LEAVE_GAMEBuilder;

struct SC_SPAWN;
struct SC_SPAWNBuilder;

struct SC_DESPAWN;
struct SC_DESPAWNBuilder;

struct C_MOVE;
struct C_MOVEBuilder;

struct SC_MOVE;
struct SC_MOVEBuilder;

struct C_SKILL;
struct C_SKILLBuilder;

struct SC_SKILL;
struct SC_SKILLBuilder;

enum ObjectState : int8_t {
  ObjectState_IDLE = 0,
  ObjectState_MOVING = 1,
  ObjectState_SKILL = 2,
  ObjectState_DEAD = 3,
  ObjectState_MIN = ObjectState_IDLE,
  ObjectState_MAX = ObjectState_DEAD
};

inline const ObjectState (&EnumValuesObjectState())[4] {
  static const ObjectState values[] = {
    ObjectState_IDLE,
    ObjectState_MOVING,
    ObjectState_SKILL,
    ObjectState_DEAD
  };
  return values;
}

inline const char * const *EnumNamesObjectState() {
  static const char * const names[5] = {
    "IDLE",
    "MOVING",
    "SKILL",
    "DEAD",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectState(ObjectState e) {
  if (::flatbuffers::IsOutRange(e, ObjectState_IDLE, ObjectState_DEAD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectState()[index];
}

enum MoveDir : int8_t {
  MoveDir_NONE = 0,
  MoveDir_UP = 1,
  MoveDir_DOWN = 2,
  MoveDir_LEFT = 3,
  MoveDir_RIGHT = 4,
  MoveDir_MIN = MoveDir_NONE,
  MoveDir_MAX = MoveDir_RIGHT
};

inline const MoveDir (&EnumValuesMoveDir())[5] {
  static const MoveDir values[] = {
    MoveDir_NONE,
    MoveDir_UP,
    MoveDir_DOWN,
    MoveDir_LEFT,
    MoveDir_RIGHT
  };
  return values;
}

inline const char * const *EnumNamesMoveDir() {
  static const char * const names[6] = {
    "NONE",
    "UP",
    "DOWN",
    "LEFT",
    "RIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoveDir(MoveDir e) {
  if (::flatbuffers::IsOutRange(e, MoveDir_NONE, MoveDir_RIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMoveDir()[index];
}

struct PlayerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4,
    VT_NAME = 6,
    VT_POSINFO = 8
  };
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const PositionInfo *posInfo() const {
    return GetPointer<const PositionInfo *>(VT_POSINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_POSINFO) &&
           verifier.VerifyTable(posInfo()) &&
           verifier.EndTable();
  }
};

struct PlayerInfoBuilder {
  typedef PlayerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(PlayerInfo::VT_PLAYERID, playerId, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PlayerInfo::VT_NAME, name);
  }
  void add_posInfo(::flatbuffers::Offset<PositionInfo> posInfo) {
    fbb_.AddOffset(PlayerInfo::VT_POSINFO, posInfo);
  }
  explicit PlayerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInfo> CreatePlayerInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0) {
  PlayerInfoBuilder builder_(_fbb);
  builder_.add_posInfo(posInfo);
  builder_.add_name(name);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerInfo> CreatePlayerInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    const char *name = nullptr,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreatePlayerInfo(
      _fbb,
      playerId,
      name__,
      posInfo);
}

struct PositionInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_MOVEDIR = 6,
    VT_POSX = 8,
    VT_POSY = 10
  };
  ObjectState state() const {
    return static_cast<ObjectState>(GetField<int8_t>(VT_STATE, 0));
  }
  MoveDir moveDir() const {
    return static_cast<MoveDir>(GetField<int8_t>(VT_MOVEDIR, 0));
  }
  int32_t posX() const {
    return GetField<int32_t>(VT_POSX, 0);
  }
  int32_t posY() const {
    return GetField<int32_t>(VT_POSY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           VerifyField<int8_t>(verifier, VT_MOVEDIR, 1) &&
           VerifyField<int32_t>(verifier, VT_POSX, 4) &&
           VerifyField<int32_t>(verifier, VT_POSY, 4) &&
           verifier.EndTable();
  }
};

struct PositionInfoBuilder {
  typedef PositionInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(ObjectState state) {
    fbb_.AddElement<int8_t>(PositionInfo::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_moveDir(MoveDir moveDir) {
    fbb_.AddElement<int8_t>(PositionInfo::VT_MOVEDIR, static_cast<int8_t>(moveDir), 0);
  }
  void add_posX(int32_t posX) {
    fbb_.AddElement<int32_t>(PositionInfo::VT_POSX, posX, 0);
  }
  void add_posY(int32_t posY) {
    fbb_.AddElement<int32_t>(PositionInfo::VT_POSY, posY, 0);
  }
  explicit PositionInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PositionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PositionInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PositionInfo> CreatePositionInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ObjectState state = ObjectState_IDLE,
    MoveDir moveDir = MoveDir_NONE,
    int32_t posX = 0,
    int32_t posY = 0) {
  PositionInfoBuilder builder_(_fbb);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  builder_.add_moveDir(moveDir);
  builder_.add_state(state);
  return builder_.Finish();
}

struct SkillInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkillInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILLID = 4
  };
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SKILLID, 4) &&
           verifier.EndTable();
  }
};

struct SkillInfoBuilder {
  typedef SkillInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillInfo::VT_SKILLID, skillId, 0);
  }
  explicit SkillInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkillInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkillInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkillInfo> CreateSkillInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skillId = 0) {
  SkillInfoBuilder builder_(_fbb);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

struct SC_ENTER_GAME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ENTER_GAMEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const PlayerInfo *player() const {
    return GetPointer<const PlayerInfo *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
};

struct SC_ENTER_GAMEBuilder {
  typedef SC_ENTER_GAME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<PlayerInfo> player) {
    fbb_.AddOffset(SC_ENTER_GAME::VT_PLAYER, player);
  }
  explicit SC_ENTER_GAMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ENTER_GAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ENTER_GAME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ENTER_GAME> CreateSC_ENTER_GAME(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<PlayerInfo> player = 0) {
  SC_ENTER_GAMEBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

struct SC_LEAVE_GAME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_LEAVE_GAMEBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SC_LEAVE_GAMEBuilder {
  typedef SC_LEAVE_GAME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SC_LEAVE_GAMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_LEAVE_GAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_LEAVE_GAME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_LEAVE_GAME> CreateSC_LEAVE_GAME(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SC_LEAVE_GAMEBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SC_SPAWN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_SPAWNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PlayerInfo>> *players() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PlayerInfo>> *>(VT_PLAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.VerifyVector(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           verifier.EndTable();
  }
};

struct SC_SPAWNBuilder {
  typedef SC_SPAWN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_players(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PlayerInfo>>> players) {
    fbb_.AddOffset(SC_SPAWN::VT_PLAYERS, players);
  }
  explicit SC_SPAWNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_SPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_SPAWN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_SPAWN> CreateSC_SPAWN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PlayerInfo>>> players = 0) {
  SC_SPAWNBuilder builder_(_fbb);
  builder_.add_players(players);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_SPAWN> CreateSC_SPAWNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PlayerInfo>> *players = nullptr) {
  auto players__ = players ? _fbb.CreateVector<::flatbuffers::Offset<PlayerInfo>>(*players) : 0;
  return CreateSC_SPAWN(
      _fbb,
      players__);
}

struct SC_DESPAWN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_DESPAWNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERIDS = 4
  };
  const ::flatbuffers::Vector<int32_t> *playerIds() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PLAYERIDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERIDS) &&
           verifier.VerifyVector(playerIds()) &&
           verifier.EndTable();
  }
};

struct SC_DESPAWNBuilder {
  typedef SC_DESPAWN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerIds(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> playerIds) {
    fbb_.AddOffset(SC_DESPAWN::VT_PLAYERIDS, playerIds);
  }
  explicit SC_DESPAWNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_DESPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_DESPAWN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_DESPAWN> CreateSC_DESPAWN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> playerIds = 0) {
  SC_DESPAWNBuilder builder_(_fbb);
  builder_.add_playerIds(playerIds);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_DESPAWN> CreateSC_DESPAWNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *playerIds = nullptr) {
  auto playerIds__ = playerIds ? _fbb.CreateVector<int32_t>(*playerIds) : 0;
  return CreateSC_DESPAWN(
      _fbb,
      playerIds__);
}

struct C_MOVE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_MOVEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSINFO = 4
  };
  const PositionInfo *posInfo() const {
    return GetPointer<const PositionInfo *>(VT_POSINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSINFO) &&
           verifier.VerifyTable(posInfo()) &&
           verifier.EndTable();
  }
};

struct C_MOVEBuilder {
  typedef C_MOVE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_posInfo(::flatbuffers::Offset<PositionInfo> posInfo) {
    fbb_.AddOffset(C_MOVE::VT_POSINFO, posInfo);
  }
  explicit C_MOVEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_MOVE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_MOVE> CreateC_MOVE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0) {
  C_MOVEBuilder builder_(_fbb);
  builder_.add_posInfo(posInfo);
  return builder_.Finish();
}

struct SC_MOVE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_MOVEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4,
    VT_POSINFO = 6
  };
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  const PositionInfo *posInfo() const {
    return GetPointer<const PositionInfo *>(VT_POSINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID, 4) &&
           VerifyOffset(verifier, VT_POSINFO) &&
           verifier.VerifyTable(posInfo()) &&
           verifier.EndTable();
  }
};

struct SC_MOVEBuilder {
  typedef SC_MOVE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(SC_MOVE::VT_PLAYERID, playerId, 0);
  }
  void add_posInfo(::flatbuffers::Offset<PositionInfo> posInfo) {
    fbb_.AddOffset(SC_MOVE::VT_POSINFO, posInfo);
  }
  explicit SC_MOVEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_MOVE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_MOVE> CreateSC_MOVE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0) {
  SC_MOVEBuilder builder_(_fbb);
  builder_.add_posInfo(posInfo);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

struct C_SKILL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_SKILLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILLINFO = 4
  };
  const SkillInfo *skillInfo() const {
    return GetPointer<const SkillInfo *>(VT_SKILLINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKILLINFO) &&
           verifier.VerifyTable(skillInfo()) &&
           verifier.EndTable();
  }
};

struct C_SKILLBuilder {
  typedef C_SKILL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skillInfo(::flatbuffers::Offset<SkillInfo> skillInfo) {
    fbb_.AddOffset(C_SKILL::VT_SKILLINFO, skillInfo);
  }
  explicit C_SKILLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_SKILL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_SKILL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_SKILL> CreateC_SKILL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SkillInfo> skillInfo = 0) {
  C_SKILLBuilder builder_(_fbb);
  builder_.add_skillInfo(skillInfo);
  return builder_.Finish();
}

struct SC_SKILL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_SKILLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERID = 4,
    VT_SKILLINFO = 6
  };
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  const SkillInfo *skillInfo() const {
    return GetPointer<const SkillInfo *>(VT_SKILLINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID, 4) &&
           VerifyOffset(verifier, VT_SKILLINFO) &&
           verifier.VerifyTable(skillInfo()) &&
           verifier.EndTable();
  }
};

struct SC_SKILLBuilder {
  typedef SC_SKILL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(SC_SKILL::VT_PLAYERID, playerId, 0);
  }
  void add_skillInfo(::flatbuffers::Offset<SkillInfo> skillInfo) {
    fbb_.AddOffset(SC_SKILL::VT_SKILLINFO, skillInfo);
  }
  explicit SC_SKILLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_SKILL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_SKILL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_SKILL> CreateSC_SKILL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    ::flatbuffers::Offset<SkillInfo> skillInfo = 0) {
  SC_SKILLBuilder builder_(_fbb);
  builder_.add_skillInfo(skillInfo);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_INGAME_H_
