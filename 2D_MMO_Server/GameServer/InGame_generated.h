// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INGAME_H_
#define FLATBUFFERS_GENERATED_INGAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

struct ObjectInfo;
struct ObjectInfoBuilder;

struct PositionInfo;
struct PositionInfoBuilder;

struct StatInfo;
struct StatInfoBuilder;

struct SkillInfo;
struct SkillInfoBuilder;

struct ItemInfo;
struct ItemInfoBuilder;

struct C_ENTER_GAME;
struct C_ENTER_GAMEBuilder;

struct SC_ENTER_GAME;
struct SC_ENTER_GAMEBuilder;

struct SC_LEAVE_GAME;
struct SC_LEAVE_GAMEBuilder;

struct SC_SPAWN;
struct SC_SPAWNBuilder;

struct SC_DESPAWN;
struct SC_DESPAWNBuilder;

struct C_MOVE;
struct C_MOVEBuilder;

struct SC_MOVE;
struct SC_MOVEBuilder;

struct C_SKILL;
struct C_SKILLBuilder;

struct SC_SKILL;
struct SC_SKILLBuilder;

struct SC_CHANGE_HP;
struct SC_CHANGE_HPBuilder;

struct SC_DIE;
struct SC_DIEBuilder;

struct SC_ITEM_LIST;
struct SC_ITEM_LISTBuilder;

struct C_EQUIP_ITEM;
struct C_EQUIP_ITEMBuilder;

struct SC_EQUIP_ITEM;
struct SC_EQUIP_ITEMBuilder;

struct C_CHANGE_MAP;
struct C_CHANGE_MAPBuilder;

struct SC_CHANGE_MAP;
struct SC_CHANGE_MAPBuilder;

enum ObjectState : int8_t {
  ObjectState_IDLE = 0,
  ObjectState_MOVING = 1,
  ObjectState_SKILL = 2,
  ObjectState_DEAD = 3,
  ObjectState_MIN = ObjectState_IDLE,
  ObjectState_MAX = ObjectState_DEAD
};

inline const ObjectState (&EnumValuesObjectState())[4] {
  static const ObjectState values[] = {
    ObjectState_IDLE,
    ObjectState_MOVING,
    ObjectState_SKILL,
    ObjectState_DEAD
  };
  return values;
}

inline const char * const *EnumNamesObjectState() {
  static const char * const names[5] = {
    "IDLE",
    "MOVING",
    "SKILL",
    "DEAD",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectState(ObjectState e) {
  if (::flatbuffers::IsOutRange(e, ObjectState_IDLE, ObjectState_DEAD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectState()[index];
}

enum MoveDir : int8_t {
  MoveDir_UP = 0,
  MoveDir_DOWN = 1,
  MoveDir_LEFT = 2,
  MoveDir_RIGHT = 3,
  MoveDir_MIN = MoveDir_UP,
  MoveDir_MAX = MoveDir_RIGHT
};

inline const MoveDir (&EnumValuesMoveDir())[4] {
  static const MoveDir values[] = {
    MoveDir_UP,
    MoveDir_DOWN,
    MoveDir_LEFT,
    MoveDir_RIGHT
  };
  return values;
}

inline const char * const *EnumNamesMoveDir() {
  static const char * const names[5] = {
    "UP",
    "DOWN",
    "LEFT",
    "RIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoveDir(MoveDir e) {
  if (::flatbuffers::IsOutRange(e, MoveDir_UP, MoveDir_RIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMoveDir()[index];
}

enum GameObjectType : int8_t {
  GameObjectType_NONE = 0,
  GameObjectType_PLAYER = 1,
  GameObjectType_MONSTER = 2,
  GameObjectType_PROJECTILE = 3,
  GameObjectType_ITEM = 4,
  GameObjectType_MIN = GameObjectType_NONE,
  GameObjectType_MAX = GameObjectType_ITEM
};

inline const GameObjectType (&EnumValuesGameObjectType())[5] {
  static const GameObjectType values[] = {
    GameObjectType_NONE,
    GameObjectType_PLAYER,
    GameObjectType_MONSTER,
    GameObjectType_PROJECTILE,
    GameObjectType_ITEM
  };
  return values;
}

inline const char * const *EnumNamesGameObjectType() {
  static const char * const names[6] = {
    "NONE",
    "PLAYER",
    "MONSTER",
    "PROJECTILE",
    "ITEM",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameObjectType(GameObjectType e) {
  if (::flatbuffers::IsOutRange(e, GameObjectType_NONE, GameObjectType_ITEM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameObjectType()[index];
}

enum SkillType : int8_t {
  SkillType_SKILL_NONE = 0,
  SkillType_SKILL_AUTO = 1,
  SkillType_SKILL_PROJECTILE = 2,
  SkillType_MIN = SkillType_SKILL_NONE,
  SkillType_MAX = SkillType_SKILL_PROJECTILE
};

inline const SkillType (&EnumValuesSkillType())[3] {
  static const SkillType values[] = {
    SkillType_SKILL_NONE,
    SkillType_SKILL_AUTO,
    SkillType_SKILL_PROJECTILE
  };
  return values;
}

inline const char * const *EnumNamesSkillType() {
  static const char * const names[4] = {
    "SKILL_NONE",
    "SKILL_AUTO",
    "SKILL_PROJECTILE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillType(SkillType e) {
  if (::flatbuffers::IsOutRange(e, SkillType_SKILL_NONE, SkillType_SKILL_PROJECTILE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillType()[index];
}

enum ItemType : int8_t {
  ItemType_ITEM_NONE = 0,
  ItemType_ITEM_WEAPON = 1,
  ItemType_ITEM_ARMOR = 2,
  ItemType_MIN = ItemType_ITEM_NONE,
  ItemType_MAX = ItemType_ITEM_ARMOR
};

inline const ItemType (&EnumValuesItemType())[3] {
  static const ItemType values[] = {
    ItemType_ITEM_NONE,
    ItemType_ITEM_WEAPON,
    ItemType_ITEM_ARMOR
  };
  return values;
}

inline const char * const *EnumNamesItemType() {
  static const char * const names[4] = {
    "ITEM_NONE",
    "ITEM_WEAPON",
    "ITEM_ARMOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemType(ItemType e) {
  if (::flatbuffers::IsOutRange(e, ItemType_ITEM_NONE, ItemType_ITEM_ARMOR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemType()[index];
}

enum WeaponType : int8_t {
  WeaponType_WEAPON_NONE = 0,
  WeaponType_WEAPON_SWORD = 1,
  WeaponType_WEAPON_BOW = 2,
  WeaponType_MIN = WeaponType_WEAPON_NONE,
  WeaponType_MAX = WeaponType_WEAPON_BOW
};

inline const WeaponType (&EnumValuesWeaponType())[3] {
  static const WeaponType values[] = {
    WeaponType_WEAPON_NONE,
    WeaponType_WEAPON_SWORD,
    WeaponType_WEAPON_BOW
  };
  return values;
}

inline const char * const *EnumNamesWeaponType() {
  static const char * const names[4] = {
    "WEAPON_NONE",
    "WEAPON_SWORD",
    "WEAPON_BOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeaponType(WeaponType e) {
  if (::flatbuffers::IsOutRange(e, WeaponType_WEAPON_NONE, WeaponType_WEAPON_BOW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeaponType()[index];
}

struct ObjectInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_NAME = 6,
    VT_POSINFO = 8,
    VT_STATINFO = 10
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const PositionInfo *posInfo() const {
    return GetPointer<const PositionInfo *>(VT_POSINFO);
  }
  const StatInfo *statInfo() const {
    return GetPointer<const StatInfo *>(VT_STATINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_POSINFO) &&
           verifier.VerifyTable(posInfo()) &&
           VerifyOffset(verifier, VT_STATINFO) &&
           verifier.VerifyTable(statInfo()) &&
           verifier.EndTable();
  }
};

struct ObjectInfoBuilder {
  typedef ObjectInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(ObjectInfo::VT_OBJECTID, objectId, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ObjectInfo::VT_NAME, name);
  }
  void add_posInfo(::flatbuffers::Offset<PositionInfo> posInfo) {
    fbb_.AddOffset(ObjectInfo::VT_POSINFO, posInfo);
  }
  void add_statInfo(::flatbuffers::Offset<StatInfo> statInfo) {
    fbb_.AddOffset(ObjectInfo::VT_STATINFO, statInfo);
  }
  explicit ObjectInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectInfo> CreateObjectInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0,
    ::flatbuffers::Offset<StatInfo> statInfo = 0) {
  ObjectInfoBuilder builder_(_fbb);
  builder_.add_statInfo(statInfo);
  builder_.add_posInfo(posInfo);
  builder_.add_name(name);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectInfo> CreateObjectInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    const char *name = nullptr,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0,
    ::flatbuffers::Offset<StatInfo> statInfo = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateObjectInfo(
      _fbb,
      objectId,
      name__,
      posInfo,
      statInfo);
}

struct PositionInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PositionInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_MOVEDIR = 6,
    VT_POSX = 8,
    VT_POSY = 10
  };
  ObjectState state() const {
    return static_cast<ObjectState>(GetField<int8_t>(VT_STATE, 0));
  }
  MoveDir moveDir() const {
    return static_cast<MoveDir>(GetField<int8_t>(VT_MOVEDIR, 0));
  }
  int32_t posX() const {
    return GetField<int32_t>(VT_POSX, 0);
  }
  int32_t posY() const {
    return GetField<int32_t>(VT_POSY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           VerifyField<int8_t>(verifier, VT_MOVEDIR, 1) &&
           VerifyField<int32_t>(verifier, VT_POSX, 4) &&
           VerifyField<int32_t>(verifier, VT_POSY, 4) &&
           verifier.EndTable();
  }
};

struct PositionInfoBuilder {
  typedef PositionInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(ObjectState state) {
    fbb_.AddElement<int8_t>(PositionInfo::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_moveDir(MoveDir moveDir) {
    fbb_.AddElement<int8_t>(PositionInfo::VT_MOVEDIR, static_cast<int8_t>(moveDir), 0);
  }
  void add_posX(int32_t posX) {
    fbb_.AddElement<int32_t>(PositionInfo::VT_POSX, posX, 0);
  }
  void add_posY(int32_t posY) {
    fbb_.AddElement<int32_t>(PositionInfo::VT_POSY, posY, 0);
  }
  explicit PositionInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PositionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PositionInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PositionInfo> CreatePositionInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ObjectState state = ObjectState_IDLE,
    MoveDir moveDir = MoveDir_UP,
    int32_t posX = 0,
    int32_t posY = 0) {
  PositionInfoBuilder builder_(_fbb);
  builder_.add_posY(posY);
  builder_.add_posX(posX);
  builder_.add_moveDir(moveDir);
  builder_.add_state(state);
  return builder_.Finish();
}

struct StatInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HP = 4,
    VT_MAXHP = 6,
    VT_SPEED = 8
  };
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t maxHp() const {
    return GetField<int32_t>(VT_MAXHP, 0);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HP, 4) &&
           VerifyField<int32_t>(verifier, VT_MAXHP, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           verifier.EndTable();
  }
};

struct StatInfoBuilder {
  typedef StatInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(StatInfo::VT_HP, hp, 0);
  }
  void add_maxHp(int32_t maxHp) {
    fbb_.AddElement<int32_t>(StatInfo::VT_MAXHP, maxHp, 0);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(StatInfo::VT_SPEED, speed, 0.0f);
  }
  explicit StatInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StatInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StatInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StatInfo> CreateStatInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hp = 0,
    int32_t maxHp = 0,
    float speed = 0.0f) {
  StatInfoBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_maxHp(maxHp);
  builder_.add_hp(hp);
  return builder_.Finish();
}

struct SkillInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkillInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILLID = 4
  };
  int32_t skillId() const {
    return GetField<int32_t>(VT_SKILLID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SKILLID, 4) &&
           verifier.EndTable();
  }
};

struct SkillInfoBuilder {
  typedef SkillInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skillId(int32_t skillId) {
    fbb_.AddElement<int32_t>(SkillInfo::VT_SKILLID, skillId, 0);
  }
  explicit SkillInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkillInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkillInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkillInfo> CreateSkillInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t skillId = 0) {
  SkillInfoBuilder builder_(_fbb);
  builder_.add_skillId(skillId);
  return builder_.Finish();
}

struct ItemInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMID = 4,
    VT_TEMPLATEID = 6,
    VT_COUNT = 8,
    VT_SLOT = 10,
    VT_EQUIPPED = 12
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  int32_t templateId() const {
    return GetField<int32_t>(VT_TEMPLATEID, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  int32_t slot() const {
    return GetField<int32_t>(VT_SLOT, 0);
  }
  bool equipped() const {
    return GetField<uint8_t>(VT_EQUIPPED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID, 4) &&
           VerifyField<int32_t>(verifier, VT_TEMPLATEID, 4) &&
           VerifyField<int32_t>(verifier, VT_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint8_t>(verifier, VT_EQUIPPED, 1) &&
           verifier.EndTable();
  }
};

struct ItemInfoBuilder {
  typedef ItemInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(ItemInfo::VT_ITEMID, itemId, 0);
  }
  void add_templateId(int32_t templateId) {
    fbb_.AddElement<int32_t>(ItemInfo::VT_TEMPLATEID, templateId, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(ItemInfo::VT_COUNT, count, 0);
  }
  void add_slot(int32_t slot) {
    fbb_.AddElement<int32_t>(ItemInfo::VT_SLOT, slot, 0);
  }
  void add_equipped(bool equipped) {
    fbb_.AddElement<uint8_t>(ItemInfo::VT_EQUIPPED, static_cast<uint8_t>(equipped), 0);
  }
  explicit ItemInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItemInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ItemInfo> CreateItemInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    int32_t templateId = 0,
    int32_t count = 0,
    int32_t slot = 0,
    bool equipped = false) {
  ItemInfoBuilder builder_(_fbb);
  builder_.add_slot(slot);
  builder_.add_count(count);
  builder_.add_templateId(templateId);
  builder_.add_itemId(itemId);
  builder_.add_equipped(equipped);
  return builder_.Finish();
}

struct C_ENTER_GAME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_ENTER_GAMEBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct C_ENTER_GAMEBuilder {
  typedef C_ENTER_GAME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit C_ENTER_GAMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_ENTER_GAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_ENTER_GAME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_ENTER_GAME> CreateC_ENTER_GAME(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  C_ENTER_GAMEBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SC_ENTER_GAME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ENTER_GAMEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4
  };
  const ObjectInfo *player() const {
    return GetPointer<const ObjectInfo *>(VT_PLAYER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           verifier.EndTable();
  }
};

struct SC_ENTER_GAMEBuilder {
  typedef SC_ENTER_GAME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<ObjectInfo> player) {
    fbb_.AddOffset(SC_ENTER_GAME::VT_PLAYER, player);
  }
  explicit SC_ENTER_GAMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ENTER_GAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ENTER_GAME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ENTER_GAME> CreateSC_ENTER_GAME(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectInfo> player = 0) {
  SC_ENTER_GAMEBuilder builder_(_fbb);
  builder_.add_player(player);
  return builder_.Finish();
}

struct SC_LEAVE_GAME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_LEAVE_GAMEBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SC_LEAVE_GAMEBuilder {
  typedef SC_LEAVE_GAME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit SC_LEAVE_GAMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_LEAVE_GAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_LEAVE_GAME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_LEAVE_GAME> CreateSC_LEAVE_GAME(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  SC_LEAVE_GAMEBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SC_SPAWN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_SPAWNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectInfo>> *objects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectInfo>> *>(VT_OBJECTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct SC_SPAWNBuilder {
  typedef SC_SPAWN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectInfo>>> objects) {
    fbb_.AddOffset(SC_SPAWN::VT_OBJECTS, objects);
  }
  explicit SC_SPAWNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_SPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_SPAWN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_SPAWN> CreateSC_SPAWN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectInfo>>> objects = 0) {
  SC_SPAWNBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_SPAWN> CreateSC_SPAWNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ObjectInfo>> *objects = nullptr) {
  auto objects__ = objects ? _fbb.CreateVector<::flatbuffers::Offset<ObjectInfo>>(*objects) : 0;
  return CreateSC_SPAWN(
      _fbb,
      objects__);
}

struct SC_DESPAWN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_DESPAWNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTIDS = 4
  };
  const ::flatbuffers::Vector<int32_t> *objectIds() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OBJECTIDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTIDS) &&
           verifier.VerifyVector(objectIds()) &&
           verifier.EndTable();
  }
};

struct SC_DESPAWNBuilder {
  typedef SC_DESPAWN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectIds(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> objectIds) {
    fbb_.AddOffset(SC_DESPAWN::VT_OBJECTIDS, objectIds);
  }
  explicit SC_DESPAWNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_DESPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_DESPAWN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_DESPAWN> CreateSC_DESPAWN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> objectIds = 0) {
  SC_DESPAWNBuilder builder_(_fbb);
  builder_.add_objectIds(objectIds);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_DESPAWN> CreateSC_DESPAWNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *objectIds = nullptr) {
  auto objectIds__ = objectIds ? _fbb.CreateVector<int32_t>(*objectIds) : 0;
  return CreateSC_DESPAWN(
      _fbb,
      objectIds__);
}

struct C_MOVE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_MOVEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSINFO = 4
  };
  const PositionInfo *posInfo() const {
    return GetPointer<const PositionInfo *>(VT_POSINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSINFO) &&
           verifier.VerifyTable(posInfo()) &&
           verifier.EndTable();
  }
};

struct C_MOVEBuilder {
  typedef C_MOVE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_posInfo(::flatbuffers::Offset<PositionInfo> posInfo) {
    fbb_.AddOffset(C_MOVE::VT_POSINFO, posInfo);
  }
  explicit C_MOVEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_MOVE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_MOVE> CreateC_MOVE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0) {
  C_MOVEBuilder builder_(_fbb);
  builder_.add_posInfo(posInfo);
  return builder_.Finish();
}

struct SC_MOVE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_MOVEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_POSINFO = 6
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  const PositionInfo *posInfo() const {
    return GetPointer<const PositionInfo *>(VT_POSINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyOffset(verifier, VT_POSINFO) &&
           verifier.VerifyTable(posInfo()) &&
           verifier.EndTable();
  }
};

struct SC_MOVEBuilder {
  typedef SC_MOVE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(SC_MOVE::VT_OBJECTID, objectId, 0);
  }
  void add_posInfo(::flatbuffers::Offset<PositionInfo> posInfo) {
    fbb_.AddOffset(SC_MOVE::VT_POSINFO, posInfo);
  }
  explicit SC_MOVEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_MOVE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_MOVE> CreateSC_MOVE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    ::flatbuffers::Offset<PositionInfo> posInfo = 0) {
  SC_MOVEBuilder builder_(_fbb);
  builder_.add_posInfo(posInfo);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct C_SKILL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_SKILLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILLINFO = 4
  };
  const SkillInfo *skillInfo() const {
    return GetPointer<const SkillInfo *>(VT_SKILLINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKILLINFO) &&
           verifier.VerifyTable(skillInfo()) &&
           verifier.EndTable();
  }
};

struct C_SKILLBuilder {
  typedef C_SKILL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skillInfo(::flatbuffers::Offset<SkillInfo> skillInfo) {
    fbb_.AddOffset(C_SKILL::VT_SKILLINFO, skillInfo);
  }
  explicit C_SKILLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_SKILL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_SKILL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_SKILL> CreateC_SKILL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SkillInfo> skillInfo = 0) {
  C_SKILLBuilder builder_(_fbb);
  builder_.add_skillInfo(skillInfo);
  return builder_.Finish();
}

struct SC_SKILL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_SKILLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_SKILLINFO = 6
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  const SkillInfo *skillInfo() const {
    return GetPointer<const SkillInfo *>(VT_SKILLINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyOffset(verifier, VT_SKILLINFO) &&
           verifier.VerifyTable(skillInfo()) &&
           verifier.EndTable();
  }
};

struct SC_SKILLBuilder {
  typedef SC_SKILL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(SC_SKILL::VT_OBJECTID, objectId, 0);
  }
  void add_skillInfo(::flatbuffers::Offset<SkillInfo> skillInfo) {
    fbb_.AddOffset(SC_SKILL::VT_SKILLINFO, skillInfo);
  }
  explicit SC_SKILLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_SKILL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_SKILL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_SKILL> CreateSC_SKILL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    ::flatbuffers::Offset<SkillInfo> skillInfo = 0) {
  SC_SKILLBuilder builder_(_fbb);
  builder_.add_skillInfo(skillInfo);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct SC_CHANGE_HP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CHANGE_HPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_HP = 6
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyField<int32_t>(verifier, VT_HP, 4) &&
           verifier.EndTable();
  }
};

struct SC_CHANGE_HPBuilder {
  typedef SC_CHANGE_HP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(SC_CHANGE_HP::VT_OBJECTID, objectId, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(SC_CHANGE_HP::VT_HP, hp, 0);
  }
  explicit SC_CHANGE_HPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CHANGE_HP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CHANGE_HP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CHANGE_HP> CreateSC_CHANGE_HP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    int32_t hp = 0) {
  SC_CHANGE_HPBuilder builder_(_fbb);
  builder_.add_hp(hp);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct SC_DIE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_DIEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_ATTACKERID = 6
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  int32_t attackerId() const {
    return GetField<int32_t>(VT_ATTACKERID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyField<int32_t>(verifier, VT_ATTACKERID, 4) &&
           verifier.EndTable();
  }
};

struct SC_DIEBuilder {
  typedef SC_DIE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(SC_DIE::VT_OBJECTID, objectId, 0);
  }
  void add_attackerId(int32_t attackerId) {
    fbb_.AddElement<int32_t>(SC_DIE::VT_ATTACKERID, attackerId, 0);
  }
  explicit SC_DIEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_DIE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_DIE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_DIE> CreateSC_DIE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    int32_t attackerId = 0) {
  SC_DIEBuilder builder_(_fbb);
  builder_.add_attackerId(attackerId);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct SC_ITEM_LIST FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ITEM_LISTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ItemInfo>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ItemInfo>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct SC_ITEM_LISTBuilder {
  typedef SC_ITEM_LIST Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ItemInfo>>> items) {
    fbb_.AddOffset(SC_ITEM_LIST::VT_ITEMS, items);
  }
  explicit SC_ITEM_LISTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ITEM_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ITEM_LIST>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ITEM_LIST> CreateSC_ITEM_LIST(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ItemInfo>>> items = 0) {
  SC_ITEM_LISTBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_ITEM_LIST> CreateSC_ITEM_LISTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ItemInfo>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<ItemInfo>>(*items) : 0;
  return CreateSC_ITEM_LIST(
      _fbb,
      items__);
}

struct C_EQUIP_ITEM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_EQUIP_ITEMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMID = 4,
    VT_EQUIPPED = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  bool equipped() const {
    return GetField<uint8_t>(VT_EQUIPPED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID, 4) &&
           VerifyField<uint8_t>(verifier, VT_EQUIPPED, 1) &&
           verifier.EndTable();
  }
};

struct C_EQUIP_ITEMBuilder {
  typedef C_EQUIP_ITEM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(C_EQUIP_ITEM::VT_ITEMID, itemId, 0);
  }
  void add_equipped(bool equipped) {
    fbb_.AddElement<uint8_t>(C_EQUIP_ITEM::VT_EQUIPPED, static_cast<uint8_t>(equipped), 0);
  }
  explicit C_EQUIP_ITEMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_EQUIP_ITEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_EQUIP_ITEM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_EQUIP_ITEM> CreateC_EQUIP_ITEM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    bool equipped = false) {
  C_EQUIP_ITEMBuilder builder_(_fbb);
  builder_.add_itemId(itemId);
  builder_.add_equipped(equipped);
  return builder_.Finish();
}

struct SC_EQUIP_ITEM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_EQUIP_ITEMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMID = 4,
    VT_EQUIPPED = 6
  };
  int32_t itemId() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  bool equipped() const {
    return GetField<uint8_t>(VT_EQUIPPED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEMID, 4) &&
           VerifyField<uint8_t>(verifier, VT_EQUIPPED, 1) &&
           verifier.EndTable();
  }
};

struct SC_EQUIP_ITEMBuilder {
  typedef SC_EQUIP_ITEM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_itemId(int32_t itemId) {
    fbb_.AddElement<int32_t>(SC_EQUIP_ITEM::VT_ITEMID, itemId, 0);
  }
  void add_equipped(bool equipped) {
    fbb_.AddElement<uint8_t>(SC_EQUIP_ITEM::VT_EQUIPPED, static_cast<uint8_t>(equipped), 0);
  }
  explicit SC_EQUIP_ITEMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_EQUIP_ITEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_EQUIP_ITEM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_EQUIP_ITEM> CreateSC_EQUIP_ITEM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t itemId = 0,
    bool equipped = false) {
  SC_EQUIP_ITEMBuilder builder_(_fbb);
  builder_.add_itemId(itemId);
  builder_.add_equipped(equipped);
  return builder_.Finish();
}

struct C_CHANGE_MAP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_CHANGE_MAPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPID = 4
  };
  int32_t mapId() const {
    return GetField<int32_t>(VT_MAPID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAPID, 4) &&
           verifier.EndTable();
  }
};

struct C_CHANGE_MAPBuilder {
  typedef C_CHANGE_MAP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mapId(int32_t mapId) {
    fbb_.AddElement<int32_t>(C_CHANGE_MAP::VT_MAPID, mapId, 0);
  }
  explicit C_CHANGE_MAPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_CHANGE_MAP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_CHANGE_MAP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_CHANGE_MAP> CreateC_CHANGE_MAP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mapId = 0) {
  C_CHANGE_MAPBuilder builder_(_fbb);
  builder_.add_mapId(mapId);
  return builder_.Finish();
}

struct SC_CHANGE_MAP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_CHANGE_MAPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAPID = 4
  };
  int32_t mapId() const {
    return GetField<int32_t>(VT_MAPID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAPID, 4) &&
           verifier.EndTable();
  }
};

struct SC_CHANGE_MAPBuilder {
  typedef SC_CHANGE_MAP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mapId(int32_t mapId) {
    fbb_.AddElement<int32_t>(SC_CHANGE_MAP::VT_MAPID, mapId, 0);
  }
  explicit SC_CHANGE_MAPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_CHANGE_MAP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_CHANGE_MAP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_CHANGE_MAP> CreateSC_CHANGE_MAP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mapId = 0) {
  SC_CHANGE_MAPBuilder builder_(_fbb);
  builder_.add_mapId(mapId);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_INGAME_H_
